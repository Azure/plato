{
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "# Training Custom Simulation using Plato Toolkit\n",
        "\n",
        "When training your custom simulation using the Ray on AML, your simulation can be wrapped in an environment to allow for easy integration. There are two options to training your custom simulation on AML:\n",
        "\n",
        "**1. Custom Environment Wrapper**\n",
        "\n",
        "2. Client API\n",
        "\n",
        "\n",
        "We will discuss how to use the Custom Environment Wrapper in this notebook. \n",
        "\n",
        "*Directions are compatible with Ray Lib 2.3.0 package"
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Prerequisites\n",
        "\n",
        "When creating a Plato Toolkit training job using AML, begin by connecting your notebook to your workspace using your Azure credentials as done below. "
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azureml.core import Workspace\n",
        "\n",
        "ws = Workspace.from_config()\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        },
        "gather": {
          "logged": 1678994472052
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "subscription_id = ws.subscription_id\n",
        "resource_group = ws.resource_group\n",
        "workspace = ws.name\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azure.ai.ml import MLClient\n",
        "from azure.identity import DefaultAzureCredential\n",
        "\n",
        "ml_client = MLClient(\n",
        "    DefaultAzureCredential(), subscription_id, resource_group, workspace\n",
        ")"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Set up Compute Cluster\n",
        "\n",
        "Set up compute cluster for model training. "
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azureml.core.compute import AmlCompute, ComputeTarget\n",
        "\n",
        "# Choose a name for the Ray cluster\n",
        "compute_name = 'compute-gpu'\n",
        "compute_min_nodes = 0\n",
        "compute_max_nodes = 2\n",
        "\n",
        "# This example uses GPU VM. For using CPU VM, set SKU to STANDARD_D2_V2\n",
        "vm_size = 'STANDARD_NC6'\n",
        "\n",
        "if compute_name in ws.compute_targets:\n",
        "    compute_target = ws.compute_targets[compute_name]\n",
        "    if compute_target and type(compute_target) is AmlCompute:\n",
        "        if compute_target.provisioning_state == 'Succeeded':\n",
        "            print('found compute target. just use it', compute_name)\n",
        "        else: \n",
        "            raise Exception(\n",
        "                'found compute target but it is in state', compute_target.provisioning_state)\n",
        "else:\n",
        "    print('creating a new compute target...')\n",
        "    provisioning_config = AmlCompute.provisioning_configuration(\n",
        "        vm_size=vm_size,\n",
        "        min_nodes=compute_min_nodes, \n",
        "        max_nodes=compute_max_nodes,\n",
        "        idle_seconds_before_scaledown=1800, # Shuts down idle compute cluster after 30 minutes\n",
        "        vm_priority='dedicated' # Choose 'lowpriority' for low priority VMs \n",
        "    )\n",
        "\n",
        "    # Create the cluster\n",
        "    compute_target = ComputeTarget.create(ws, compute_name, provisioning_config)\n",
        "    \n",
        "    # Can poll for a minimum number of nodes and for a specific timeout. \n",
        "    # If no min node count is provided it will use the scale settings for the cluster\n",
        "    compute_target.wait_for_completion(show_output=True, min_node_count=None, timeout_in_minutes=20)\n",
        "    \n",
        "    # For a more detailed view of current AmlCompute status, use get_status()\n",
        "    print(compute_target.get_status().serialize())"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Check compute cluster target \n",
        "ws.get_default_compute_target(type) # Possible values should be 'CPU' or 'GPU'"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Custom Simulation Environment Wrapper\n",
        "\n",
        "Custom Simulations can be created using the BaseEnv API on the Ray package. A custom simulation is created into a gymnastics environment that is compatible with RLLib training. The BasicEnv API requires three functions within the larger simulation class:\n",
        "\n",
        "1. init\n",
        "2. step\n",
        "3. reset \n"
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "import gymnasium as gym\n",
        "from collections import deque\n",
        "import numpy as np\n",
        "from sim.simulator_model import SimulatorModel\n",
        "from ray.rllib.env.base_env import BaseEnv\n",
        "from utils.callbacks import MyCallback\n",
        "\n",
        "from training_setup.rl_lesson_init import rl_lesson_init\n",
        "from training_setup.rl_sim_spec import RLSimSpec\n",
        "\n",
        "\n",
        "class Gym_Wrapper(gym.Env, gym.utils.EzPickle):\n",
        " \"\"\"\n",
        " Gymastic wrapper for custom environment calls on Ray gym package and pickles the simulation. Simulation\n",
        " episodes are calls to json files with episode information. Make sure Simulation document has the following\n",
        " defined:\n",
        "    - step(action: Dict[str, Any])\n",
        "    - reset((config: Dict[str, Any])\n",
        "    - get_state() -> Dict[str, Any]\n",
        " \"\"\"   \n",
        "    \n",
        "    def __init__(self,\n",
        "                 config = {},\n",
        "                 **kwargs):\n",
        "        gym.utils.EzPickle.__init__(\n",
        "            self,\n",
        "            config,\n",
        "        )\n",
        "\n",
        "        super().__init__()\n",
        "        \n",
        "        # Save the environmental config parsed from tune.run\n",
        "        # This includes the following feats: {, worker=1/11, vector_idx=0, remote=False} -\n",
        "        self.config = config\n",
        "\n",
        "        # Define episode reset config\n",
        "        self.rl_lesson_config = self.config.get('rl_lesson_config', {})\n",
        "\n",
        "        # Initialize sim specification\n",
        "        self.rl_sim_spec = RLSimSpec()\n",
        "\n",
        "        # Define the simulator model\n",
        "        self.sim = SimulatorModel()\n",
        "\n",
        "        # Dimensions of the grid.\n",
        "        self.XX = kwargs.get('XX',3)\n",
        "\n",
        "        # Get specs for states and actions from the simulator\n",
        "        self.state_dim, self.action_dim = self.rl_sim_spec.get_gym_specs()\n",
        "\n",
        "        # Configure states\n",
        "        self.observation_space = gym.spaces.Box(low=-1.0, high=1.0, shape=(self.state_dim,), dtype=np.float32)\n",
        "        assert np.array([0]*self.state_dim, np.float32) in self.observation_space\n",
        "    \n",
        "\n",
        "        # Configure Actions\n",
        "        self.action_space = gym.spaces.Box(low=-1.0, high=1.0, shape=(self.action_dim,), dtype=np.float32)\n",
        "\n",
        "\n",
        "    def step(self, action):\n",
        "        ''' apply the supplied action '''\n",
        "\n",
        "        # Take the action\n",
        "        sim_action = self.rl_sim_spec.gym_action_to_sim(action)\n",
        "        state_dict = self.sim.step(sim_action)\n",
        "\n",
        "        # Convert the state to a Gym state\n",
        "        state = self.rl_sim_spec.sim_state_to_gym(state_dict)\n",
        "        # clip the state to the observation space\n",
        "        state = np.clip(state, self.observation_space.low, self.observation_space.high)\n",
        "\n",
        "        # Get -1 reward for each step\n",
        "        # - Except at the terminal state which has zero reward\n",
        "        # - Set the 'terminated' flag if we've reached thermal runaway\n",
        "        terminated = self.sim.termination()\n",
        "        truncated = self.sim.truncation()\n",
        "        reward, terminated, truncated = self.rl_sim_spec.compute_reward_term_and_trun(state_dict, terminated, truncated)\n",
        "\n",
        "        info = {}\n",
        "        # Add states to track in the info dict (for logging)\n",
        "        # - This is used by the 'monitor' wrapper to record the states\n",
        "        for state_name in self.rl_sim_spec.get_states_to_log():\n",
        "            info[\"state_\" + state_name] = state_dict[state_name]\n",
        "\n",
        "        return state, reward, terminated, truncated, info\n",
        "\n",
        "\n",
        "    def reset(self, *, seed=None, options=None):\n",
        "        # Seed and options needed for ray 2.3.0 compatibility\n",
        "        super().reset(seed=seed)\n",
        "        \n",
        "        # Setup values for sim config whenever \"rl_lesson\" has been defined.\n",
        "        reset_config = rl_lesson_init(self.rl_lesson_config)\n",
        "        state_dict = self.sim.reset(reset_config)\n",
        "        # Convert the state to a Gym state\n",
        "        state = self.rl_sim_spec.sim_state_to_gym(state_dict)\n",
        "        state = np.clip(state, self.observation_space.low, self.observation_space.high)\n",
        "\n",
        "        info = {}\n",
        "        return state, info\n",
        "\n",
        "\n",
        "    def render(self, action=0, reward=0 ):\n",
        "        states=[]\n",
        "        print(f\"(action: {action}): (states: {states}) reward = {reward}\")\n"
      ],
      "outputs": [
        {
          "output_type": "error",
          "ename": "IndentationError",
          "evalue": "unexpected indent (571552409.py, line 6)",
          "traceback": [
            "\u001b[0;36m  Input \u001b[0;32mIn [2]\u001b[0;36m\u001b[0m\n\u001b[0;31m    def __init__(self,\u001b[0m\n\u001b[0m    ^\u001b[0m\n\u001b[0;31mIndentationError\u001b[0m\u001b[0;31m:\u001b[0m unexpected indent\n"
          ]
        }
      ],
      "execution_count": 2,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        },
        "gather": {
          "logged": 1678999462784
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Setup rl_lesson config\n",
        "\n",
        "import yaml\n",
        "with open(\"training_setup/rl_lesson.yml\", \"r\") as file:\n",
        "    rl_lesson_config = yaml.safe_load(file)\n",
        "    config = {\"rl_lesson_config\": rl_lesson_config}\n",
        "    print(\"config: \", config)\n",
        "\n",
        "\n",
        "    # use the Ray 'check_env' function to check the environment\n",
        "    # -- requires pip install opencv-python --\n",
        "    from ray.rllib.utils.pre_checks.env import check_env as ray_check_env\n",
        "    ray_check_env(env)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Create an instance of our custom environment\n",
        "\n",
        "env = Gym_Wrapper(config)\n",
        "\n",
        "print(env.action_space)\n",
        "print(env.observation_space)\n",
        "print(env.reset())\n",
        "print(env.step([1]))"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Use the Gymnasium 'check_env' function to check the environment\n",
        "# - returns nothing if the environment is verified as ok\n",
        "\n",
        "from gymnasium.utils.env_checker import check_env\n",
        "check_env(env)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Use the Ray 'check_env' function to check the environment\n",
        "# -- requires pip install opencv-python --\n",
        "\n",
        "from ray.rllib.utils.pre_checks.env import check_env as ray_check_env\n",
        "ray_check_env(env)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Create Ray Environment on Azure "
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Run Environment \n",
        "import os\n",
        "from azureml.core import Environment\n",
        "\n",
        "ray_docker_path = 'Dockerfile'\n",
        "\n",
        "ray_environment = Environment. \\\n",
        "    from_dockerfile(name = 'CSTR', dockerfile= ray_docker_path). \\\n",
        "    register(workspace=ws)\n",
        "\n",
        "ray_build = ray_environment.build(workspace=ws)\n",
        "\n",
        "ray_build.wait_for_completion(show_output = True)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from ray.tune import register_env\n",
        "\n",
        "# Initiate training algorithm, call on rl environment, and collect Wrapped Simulation\n",
        "training_algorithm = \"PPO\"\n",
        "rl_environment = \"CTSR\"\n",
        "script_name = 'custom_rllib_run.py'\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azureml.core import RunConfiguration, ScriptRunConfig\n",
        "from azureml.core.experiment import Experiment\n",
        "\n",
        "Experiment(worspace=ws, \"CSTR-Experiment\")\n",
        "\n",
        "\n",
        "aml_run_config_ml = RunConfiguration(communicator='OpenMpi')\n",
        "aml_run_config_ml.target = compute_target\n",
        "aml_run_config_ml.node_count = 2\n",
        "aml_run_config_ml.environment = ray_environment\n",
        "\n",
        "command=[\n",
        "    'python', script_name,\n",
        "    '--run', training_algorithm,\n",
        "    '--env', rl_environment,\n",
        "    '--config', '\\'{\"num_gpus\": 4, \"num_workers\": 11}\\'',\n",
        "]\n",
        "\n",
        "config = ScriptRunConfig(source_directory='./files',\n",
        "                    command=command,\n",
        "                    run_config = aml_run_config_ml\n",
        "                   )\n",
        "training_run = Experiment.submit(config)\n",
        "\n",
        "training_run.wait_for_completion()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azureml.widgets import RunDetails\n",
        "\n",
        "RunDetails(training_run).show()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Conclusion "
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "Now that you have created a custom Simulation using Gymnasium, you can train your model using Ray. Do not forget to shut down your compute instance and archive your training run. "
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# To archive the created experiment:\n",
        "Experiment.archive()\n",
        "\n",
        "# To delete created compute instance\n",
        "if not current_compute_instance:\n",
        "    compute_target.delete()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "#"
      ],
      "metadata": {
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python310-sdkv2",
      "language": "python",
      "display_name": "Python 3.10 - SDK v2"
    },
    "language_info": {
      "name": "python",
      "version": "3.10.9",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "file_extension": ".py"
    },
    "microsoft": {
      "ms_spell_check": {
        "ms_spell_check_language": "en"
      }
    },
    "nteract": {
      "version": "nteract-front-end@1.0.0"
    },
    "kernel_info": {
      "name": "python310-sdkv2"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}